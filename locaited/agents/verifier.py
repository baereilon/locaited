"""
Event Verifier Agent - Validates event specificity and temporality.

This agent is responsible for determining whether events generated by the
Researcher are specific enough (have date and location) and are future events
(not past or unclear).
"""

import logging
from abc import ABC, abstractmethod
from typing import Dict, Any, List, Tuple
from datetime import datetime

from locaited.agents.base_agent import BaseAgent

logger = logging.getLogger(__name__)


class EventVerification:
    """Data structure for verification results."""
    
    def __init__(self, event: Dict[str, Any]):
        self.event = event
        self.is_specific: bool = False
        self.has_date: bool = False
        self.has_location: bool = False
        self.has_time: bool = False  # Bonus, not required
        self.temporality: str = "UNCLEAR"  # FUTURE, PAST, ONGOING, UNCLEAR
        self.confidence: float = 0.0
        self.should_keep: bool = False
        
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for state passing."""
        return {
            "event": self.event,
            "is_specific": self.is_specific,
            "specificity_details": {
                "has_date": self.has_date,
                "has_location": self.has_location,
                "has_time": self.has_time
            },
            "temporality": self.temporality,
            "confidence": self.confidence,
            "should_keep": self.should_keep
        }


class VerifierInterface(ABC):
    """Abstract interface for verifier implementations."""
    
    @abstractmethod
    def verify_event(self, event: Dict[str, Any]) -> EventVerification:
        """Verify a single event for specificity and temporality."""
        pass
    
    @abstractmethod
    def verify_batch(self, events: List[Dict[str, Any]]) -> List[EventVerification]:
        """Verify a batch of events."""
        pass


class VerifierAgent(BaseAgent):
    """
    Base Verifier agent that delegates to specific implementations.
    
    Supports two implementations:
    - LLM-based verification using GPT-3.5
    - LlamaIndex-based verification using pattern matching
    """
    
    def __init__(self, implementation: str = "llm", use_cache: bool = True):
        """
        Initialize Verifier agent.
        
        Args:
            implementation: "llm" or "llamaindex"
            use_cache: Whether to cache verification decisions
        """
        super().__init__(name="verifier", use_cache=use_cache)
        
        self.implementation = implementation
        logger.info(f"Initializing Verifier with {implementation} implementation")
        
        # Initialize the appropriate implementation
        if implementation == "llm":
            from locaited.agents.verifier_llm import VerifierLLM
            self.verifier = VerifierLLM()
        elif implementation == "llamaindex":
            from locaited.agents.verifier_llamaindex import VerifierLlamaIndex
            self.verifier = VerifierLlamaIndex()
        else:
            raise ValueError(f"Unknown implementation: {implementation}")
    
    def process(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """
        Process events from Researcher for verification.
        
        Args:
            state: Workflow state containing events_to_verify
            
        Returns:
            Updated state with verification results
        """
        try:
            # Extract events to verify
            events_to_verify = state.get("events_to_verify", [])
            
            if not events_to_verify:
                logger.warning("No events to verify")
                state["verification_results"] = []
                state["verified_events"] = []
                state["rejected_events"] = []
                state["needs_more_events"] = True
                return state
            
            logger.info(f"VERIFIER: Processing {len(events_to_verify)} events with {self.implementation}")
            
            # Check cache for each event
            verification_results = []
            uncached_events = []
            
            for event in events_to_verify:
                cache_key = self._get_cache_key(event)
                cached_result = self.get_from_cache(cache_key) if self.use_cache else None
                
                if cached_result:
                    logger.debug(f"Using cached verification for: {event.get('description', '')[:50]}...")
                    verification_results.append(cached_result)
                else:
                    uncached_events.append(event)
            
            # Verify uncached events
            if uncached_events:
                logger.info(f"Verifying {len(uncached_events)} uncached events")
                new_verifications = self.verifier.verify_batch(uncached_events)
                
                # Cache and add results
                for verification in new_verifications:
                    cache_key = self._get_cache_key(verification.event)
                    result_dict = verification.to_dict()
                    
                    if self.use_cache:
                        self.save_to_cache(cache_key, result_dict)
                    
                    verification_results.append(result_dict)
            
            # Process results
            verified_events = []
            rejected_events = []
            
            for result in verification_results:
                event_desc = result["event"].get("description", "")[:50]
                
                # An event must be BOTH specific AND future to pass
                if result["is_specific"] and result["temporality"] == "FUTURE":
                    result["should_keep"] = True
                    verified_events.append(result)
                    logger.info(f"✓ PASSED: {event_desc}... (specific + future)")
                else:
                    result["should_keep"] = False
                    rejected_events.append(result)
                    
                    reasons = []
                    if not result["is_specific"]:
                        reasons.append("not specific")
                    if result["temporality"] != "FUTURE":
                        reasons.append(f"temporality: {result['temporality'].lower()}")
                    
                    logger.info(f"✗ FAILED: {event_desc}... ({', '.join(reasons)})")
            
            # Update state
            state["verification_results"] = verification_results
            state["verified_events"] = verified_events
            state["rejected_events"] = rejected_events
            state["needs_more_events"] = len(verified_events) < 15
            
            # Log summary
            logger.info(f"VERIFIER COMPLETE: {len(verified_events)}/{len(events_to_verify)} passed")
            logger.info(f"  - Specific: {sum(1 for r in verification_results if r['is_specific'])}")
            logger.info(f"  - Future: {sum(1 for r in verification_results if r['temporality'] == 'FUTURE')}")
            logger.info(f"  - Both: {len(verified_events)}")
            
            # Track metrics
            state["verifier_metrics"] = {
                "total_events": len(events_to_verify),
                "passed": len(verified_events),
                "failed": len(rejected_events),
                "specificity_rate": sum(1 for r in verification_results if r["is_specific"]) / len(verification_results) if verification_results else 0,
                "future_rate": sum(1 for r in verification_results if r["temporality"] == "FUTURE") / len(verification_results) if verification_results else 0,
                "implementation": self.implementation
            }
            
            return state
            
        except Exception as e:
            logger.error(f"Verifier error: {e}")
            state["verifier_error"] = str(e)
            state["needs_more_events"] = True
            return state
    
    def _get_cache_key(self, event: Dict[str, Any]) -> str:
        """Generate cache key for an event."""
        description = event.get("description", "")
        return f"verify_{self.implementation}_{hash(description)}"